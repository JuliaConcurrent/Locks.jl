var documenterSearchIndex = {"docs":
[{"location":"api/#API-overview","page":"API overview","title":"API overview","text":"","category":"section"},{"location":"api/","page":"API overview","title":"API overview","text":"using DocumentationOverview\nusing Locks\nDocumentationOverview.table_md(\n    Locks;\n    signature = :strip_namespace,\n    include = api -> api.hasdoc && !(api.value isa Module),\n)","category":"page"},{"location":"#Locks.jl","page":"Locks.jl","title":"Locks.jl","text":"","category":"section"},{"location":"","page":"Locks.jl","title":"Locks.jl","text":"using DocumentationOverview\nusing Locks\nDocumentationOverview.table_md(\n    Locks,\n    signature = :name,\n    include = api -> api.hasdoc && !(api.value isa Module),\n)","category":"page"},{"location":"","page":"Locks.jl","title":"Locks.jl","text":"ReentrantCLHLock\nNonreentrantCLHLock\nReentrantBackoffSpinLock\nNonreentrantBackoffSpinLock\nTaskObliviousLock\nacquire\nrelease\ntry_race_acquire\nrace_acquire\nacquire_then","category":"page"},{"location":"#Locks.ReentrantCLHLock","page":"Locks.jl","title":"Locks.ReentrantCLHLock","text":"ReentrantCLHLock\n\nA reentrant CLH \"spinnable\" lock that provides first-come-first-served fairness.  Keyword argument nspins::Integer can be passed to acquire to specify a number of spins tried before falling back to \"cooperative\" waiting in the Julia scheduler.\n\nExtended help\n\nReentrantCLHLock implements the spin lock by Craig (1993) and Magnussen, Landin, and Hagersten (1994) with a fallback to \"cooperatively\" wait in the scheduler instead of spinning (hence \"spinnable\").  See NonreentrantCLHLock that provides a non-reentrant version.\n\nMemory ordering\n\nA release invocation on a lock establishes happened-before edges to subsequent invocations of acquire and try_race_acquire that returns an Ok on the same lock.\n\nSupported operations\n\nacquire(lock::ReentrantCLHLock; [nspins::Integer]) (lock)\ntry_race_acquire(lock::ReentrantCLHLock) (trylock): Not very efficient but lock-free.  Fail with AcquiredByWriterError.\nrelease(lock::ReentrantCLHLock) (unlock)\n\n\n\n\n\n","category":"type"},{"location":"#Locks.NonreentrantCLHLock","page":"Locks.jl","title":"Locks.NonreentrantCLHLock","text":"NonreentrantCLHLock\n\nA (non-reentrant) CLH \"spinnable\" lock that provides first-come-first-served fairness. Keyword argument nspins::Integer can be passed to acquire to specify a number of spins tried before falling back to \"cooperative\" waiting in the Julia scheduler.\n\nExtended help\n\nNonreentrantCLHLock implements the spin lock by Craig (1993) and Magnussen, Landin, and Hagersten (1994) with a fallback to \"cooperatively\" wait in the scheduler instead of spinning (hence \"spinnable\").  See ReentrantCLHLock that provides a reentrant version.\n\nMemory ordering\n\nNonreentrantCLHLock has the same semantics as ReentrantCLHLock provided that each hand-off of the lock between tasks (if any) establishes a happened-before edge.\n\nSupported operations\n\nacquire(lock::NonreentrantCLHLock; [nspins::Integer]) (lock)\ntry_race_acquire(lock::NonreentrantCLHLock) (trylock): Not very efficient but lock-free.  Fail with AcquiredByWriterError.\nrelease(lock::NonreentrantCLHLock) (unlock)\n\n\n\n\n\n","category":"type"},{"location":"#Locks.ReentrantBackoffSpinLock","page":"Locks.jl","title":"Locks.ReentrantBackoffSpinLock","text":"ReentrantBackoffSpinLock\n\nA reentrant exponential backoff spin lock.\n\nSee also NonreentrantBackoffSpinLock that provides a non-reentrant version.\n\nExtended help\n\nMemory ordering\n\nA release invocation on a lock establishes happened-before edges to subsequent invocations of acquire and try_race_acquire that returns an Ok on the same lock.\n\nSupported operations\n\nReentrantBackoffSpinLock(; [mindelay], [maxdelay]) -> lock: Create a lock. mindelay (default: 1) specifies the number of spinloop called in the initial backoff.  mindelay (default: 1000) specifies the maximum backoff.\nacquire(lock::ReentrantBackoffSpinLock; [mindelay], [maxdelay]) (lock): Acquire the lock.  Keyword arguments mindelay and maxdelay can be passed to override the values specified by the constructor.\ntry_race_acquire(lock::ReentrantBackoffSpinLock) (trylock):\nrelease(lock::ReentrantBackoffSpinLock) (unlock)\n\n\n\n\n\n","category":"type"},{"location":"#Locks.NonreentrantBackoffSpinLock","page":"Locks.jl","title":"Locks.NonreentrantBackoffSpinLock","text":"NonreentrantBackoffSpinLock\n\nA non-reentrant exponential backoff spin lock.\n\nSee also ReentrantBackoffSpinLock that provides a reentrant version.\n\nExtended help\n\nNonreentrantBackoffSpinLock performs better than Base.Threads.SpinLock with high contention.  NonreentrantCLHLock is better than NonreentrantBackoffSpinLock with high contention with many worker threads (20 to 80; it depends on the machine).\n\nSince NonreentrantBackoffSpinLock does not have a fallback \"cooperative\" waiting mechanism, NonreentrantCLHLock is in general recommended.\n\nMemory ordering\n\nNonreentrantBackoffSpinLock has the same semantics as ReentrantBackoffSpinLock provided that each hand-off of the lock between tasks (if any) establishes a happened-before edge.\n\nSupported operations\n\nNonreentrantBackoffSpinLock(; [mindelay], [maxdelay]) -> lock: Create a lock. mindelay (default: 1) specifies the number of spinloop called in the initial backoff.  mindelay (default: 1000) specifies the maximum backoff.\nacquire(lock::NonreentrantBackoffSpinLock; [mindelay], [maxdelay]) (lock): Acquire the lock.  Keyword arguments mindelay and maxdelay can be passed to override the values specified by the constructor.\ntry_race_acquire(lock::NonreentrantBackoffSpinLock) (trylock):\nrelease(lock::NonreentrantBackoffSpinLock) (unlock)\n\n\n\n\n\n","category":"type"},{"location":"#Locks.TaskObliviousLock","page":"Locks.jl","title":"Locks.TaskObliviousLock","text":"TaskObliviousLock\n\nA lock that can be released in a task that did not acquire the lock.  It does not support reentrancy.\n\nExtended help\n\nExamples\n\njulia> using Locks\n\njulia> lock = TaskObliviousLock();\n\njulia> acquire(lock);\n\njulia> wait(Threads.@spawn release(lock));  # completes\n\nSupported operations\n\nacquire(lock::TaskObliviousLock) (lock)\nrelease(lock::TaskObliviousLock) (unlock)\n\nImplementation detail\n\nTaskObliviousLock is an alias to unspecified implementation of lock.  Currently, it is:\n\njulia> TaskObliviousLock === NonreentrantCLHLock\ntrue\n\n\n\n\n\n","category":"type"},{"location":"#Locks.acquire","page":"Locks.jl","title":"Locks.acquire","text":"acquire(lock)\n\nAcquire a lock.  It is equivalent to Base.lock(lock) but it may support additional keyword arguments.\n\nSee also release and try_race_acquire.\n\nExtended help\n\nExamples\n\njulia> using Locks\n\njulia> lock = ReentrantCLHLock();\n\njulia> acquire(lock);\n\njulia> release(lock);\n\nOn naming\n\nLocks.jl uses acquire/release instead of lock/unlock so that:\n\nVariable lock can be used.\nMake it clear that Locks.try_race_acquire(lock) -> result::Union{Ok,Err} and Base.trylock(lock) -> locked::Bool have different return types.  In particular, try_race_acquire can report the reason why certain attempt have failed.\n\n\n\n\n\n","category":"function"},{"location":"#Locks.release","page":"Locks.jl","title":"Locks.release","text":"release(lock)\n\nRelease a lock.  It is equivalent to Base.unlock(lock).\n\nSee also acquire and try_race_acquire.\n\n\n\n\n\n","category":"function"},{"location":"#Locks.try_race_acquire","page":"Locks.jl","title":"Locks.try_race_acquire","text":"try_race_acquire(lock) -> Ok(nothing) or Err(reason)\n\nTry to acquire lock and return Ok(nothing) on success.  Return an Err wrapping a value explaining a reason of failure.\n\nSee the documentation of typeof(lock) for possible error types.\n\nExamples\n\njulia> using Locks\n\njulia> lock = NonreentrantCLHLock();\n\njulia> try_race_acquire(lock)\nTry.Ok: nothing\n\njulia> try_race_acquire(lock)\nTry.Err: TooManyTries(0, 0)\n\n\n\n\n\n","category":"function"},{"location":"#Locks.race_acquire","page":"Locks.jl","title":"Locks.race_acquire","text":"race_acquire(lock) -> isacquired::Bool\n\nTry to acquire lock and return true on success and false on failure.\n\nSee also try_race_acquire.\n\nExamples\n\njulia> using Locks\n\njulia> lock = NonreentrantCLHLock();\n\njulia> race_acquire(lock)\ntrue\n\njulia> race_acquire(lock)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"#Locks.acquire_then","page":"Locks.jl","title":"Locks.acquire_then","text":"acquire_then(f, lock; acquire_options...) -> y\n\nExecute a thunk f in a critical section protected by lock and return the value y returned from f.  Keyword arguments are passed to acquire.\n\nExtended help\n\nExamples\n\njulia> using Locks\n\njulia> lock = ReentrantCLHLock();\n\njulia> acquire_then(lock; nspins = 10) do\n           123 + 456\n       end\n579\n\n\n\n\n\n","category":"function"}]
}
